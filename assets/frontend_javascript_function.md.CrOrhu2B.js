import{_ as i,c as s,o as a,a5 as l}from"./chunks/framework.ByOCcFwP.js";const E=JSON.parse('{"title":"javascript 函数","description":"","frontmatter":{"title":"javascript 函数","date":"2019-12-23T20:07:34.000Z","categories":"javascript","tags":["funcation"]},"headers":[],"relativePath":"frontend/javascript/function.md","filePath":"frontend/javascript/function.md"}'),n={name:"frontend/javascript/function.md"},e=l(`<h2 id="函数的作用" tabindex="-1">函数的作用 <a class="header-anchor" href="#函数的作用" aria-label="Permalink to &quot;函数的作用&quot;">​</a></h2><ul><li>解决代码冗余问题，提高代码复用率</li><li>实现代码的模块化</li><li>封装代码，是函数内部代码对外部不可见</li></ul><h2 id="函数三要素" tabindex="-1">函数三要素 <a class="header-anchor" href="#函数三要素" aria-label="Permalink to &quot;函数三要素&quot;">​</a></h2><ul><li>函数名，最好使用动词，经常使用 <code>get</code>， <code>set</code> 作为前缀</li><li>参数，定义函数是括号内的为形参，调用函数时传递实参，形参一般是变量，实参是具体的值</li><li>返回值，函数通常会通过 <code>return</code> 返回值作为函数调用表达式的值，若无 <code>return</code> 默认返回 <code>undefined</code></li><li>函数是否需要参数和返回值需要具体判断</li></ul><h2 id="函数的使用" tabindex="-1">函数的使用 <a class="header-anchor" href="#函数的使用" aria-label="Permalink to &quot;函数的使用&quot;">​</a></h2><h3 id="字面量定义" tabindex="-1">字面量定义 <a class="header-anchor" href="#字面量定义" aria-label="Permalink to &quot;字面量定义&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">funcation </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">funcName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (argument1, argument2) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    statement;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="表达式定义" tabindex="-1">表达式定义 <a class="header-anchor" href="#表达式定义" aria-label="Permalink to &quot;表达式定义&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> funcName funcation (argument1, argument2) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    statement;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="函数调用" tabindex="-1">函数调用 <a class="header-anchor" href="#函数调用" aria-label="Permalink to &quot;函数调用&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">funcName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value1, value2);                 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//函数调用表达式</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">funcName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value1, value2));    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//控制台直接输出返回值</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> funcName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value1, value2);    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//使用变量存储返回值</span></span></code></pre></div><h3 id="函数实参伪数组" tabindex="-1">函数实参伪数组 <a class="header-anchor" href="#函数实参伪数组" aria-label="Permalink to &quot;函数实参伪数组&quot;">​</a></h3><ul><li>每个函数内部都会有一个名为 <code>arguments</code> 的实参伪数组</li><li>可以通过 <code>arguments.length</code> 获取参数个数，<code>arguments[i]</code> 获取第 <code>i</code> 个参数</li></ul><h2 id="函数作用域" tabindex="-1">函数作用域 <a class="header-anchor" href="#函数作用域" aria-label="Permalink to &quot;函数作用域&quot;">​</a></h2><ul><li>作用域表示变量起作用的范围，主要用来隔离变量（函数外部与函数内部的同名变量没有关系）</li><li>通常情况函数外部是全局作用域，函数内部是局部作用域（函数作用域）</li><li>全局作用域中的变量称为全局变量，局部作用域中的变量称为局部变量</li><li>全局变量可以在函数内部操作，但局部变量无法在全局作用域中操作</li><li><strong>特殊情况</strong> 在函数内部的变量没有使用 <code>var</code> 关键字时： <ul><li>首先判断该变量是否是形参，是形参作为局部变量处理</li><li>若该变量不是形参，判断全局作用域中有无该变量，有则直接操作全局变量</li><li>若全局作用域中无该变量，则相当于在函数外部定义新的全局变量</li></ul></li><li>作用域在函数定义时就已经确定了</li></ul><h2 id="作用域链" tabindex="-1">作用域链 <a class="header-anchor" href="#作用域链" aria-label="Permalink to &quot;作用域链&quot;">​</a></h2><ul><li>作用域链指的是变量通过一定的规则去查找，查找的过程称为作用域链： <ul><li>先从自己的作用域中查找，找不到则去上级作用域查找，找到该变量则不再继续查找</li><li>若直到全局作用域都没有找到，则会报错（提示变量未定义）</li></ul></li><li>作用域链在函数调用时才会存在，每个执行环境都有自己独立的作用域链</li></ul><h2 id="预解析-变量提升" tabindex="-1">预解析（变量提升） <a class="header-anchor" href="#预解析-变量提升" aria-label="Permalink to &quot;预解析（变量提升）&quot;">​</a></h2><ul><li>代码执行之前会进行预解析，域解析会解析所有包含 <code>var</code> 关键字的变量和函数：</li><li>预解析时函数优先级比变量要高，先解析所有的函数，再解析变量： <ul><li>函数重名，后面的覆盖前面的</li><li>变量重名，会忽略后面的变量</li><li>字面量定义函数，整个函数被提升</li><li>表达式定义函数，只提升变量（函数当做使用 <code>var</code> 关键字的变量）</li><li>没有 <code>var</code> 关键字的变量不是进行预解析</li></ul></li></ul><h2 id="立即调用函数表达式" tabindex="-1">立即调用函数表达式 <a class="header-anchor" href="#立即调用函数表达式" aria-label="Permalink to &quot;立即调用函数表达式&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello function!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})();</span></span></code></pre></div><ul><li><code>IIFE</code> 全称 <code>Immediately Invoked Function Expression</code>，中文<strong>立即调用函数表达式</strong>，别名<strong>匿名函数自调用表达式</strong></li><li>声明函数的同时会立即调用这个表达式，特点： <ul><li>函数只执行一次</li><li>定义的同时执行</li><li>函数不参与预解析，但函数内部会进行预解析</li></ul></li><li>作用： <ul><li>隐藏代码实现，只向外部暴露必要部分，封装插件可能用到</li><li>防止外部命名空间被污染</li><li>对项目进行初始化</li></ul></li></ul><h2 id="函数的递归调用" tabindex="-1">函数的递归调用 <a class="header-anchor" href="#函数的递归调用" aria-label="Permalink to &quot;函数的递归调用&quot;">​</a></h2><ul><li>一个函数在内部又调用了自身称为函数的递归调用</li><li>函数的递归调用比较消耗内存，使用时应该注意： <ul><li>必须有一个明显的结束条件</li><li>必须有一个趋近结束条件的趋势</li></ul></li></ul><h3 id="求阶乘" tabindex="-1">求阶乘 <a class="header-anchor" href="#求阶乘" aria-label="Permalink to &quot;求阶乘&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getFactorial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callee</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="回调函数" tabindex="-1">回调函数 <a class="header-anchor" href="#回调函数" aria-label="Permalink to &quot;回调函数&quot;">​</a></h2><ul><li>定义一个函数后，没有调用，但是函数却执行了，这种函数称为回调函数</li><li>回调函数一般都是作为参数传递的</li><li>dom 事件多为回调函数</li></ul>`,28),t=[e];function h(p,k,r,d,o,c){return a(),s("div",null,t)}const g=i(n,[["render",h]]);export{E as __pageData,g as default};
