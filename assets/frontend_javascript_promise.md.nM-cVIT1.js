import{_ as e,c as o,o as r,a5 as i}from"./chunks/framework.ByOCcFwP.js";const u=JSON.parse('{"title":"Promise 对象","description":"","frontmatter":{"title":"Promise 对象","date":"2020-03-13T18:58:28.000Z","categories":"javascript","tags":["promise"]},"headers":[],"relativePath":"frontend/javascript/promise.md","filePath":"frontend/javascript/promise.md"}'),a={name:"frontend/javascript/promise.md"},l=i('<h2 id="promise-简介" tabindex="-1">Promise 简介 <a class="header-anchor" href="#promise-简介" aria-label="Permalink to &quot;Promise 简介&quot;">​</a></h2><ul><li>Promise 是异步编程的一种解决方案，比传统的回调函数和事件解决异步更加合理和灵活 <ul><li>异步操作 <ul><li>文件处理</li><li>网络请求 (AJAX, 爬虫)</li><li>数据库操作</li><li>定时器</li></ul></li></ul></li><li>Promise 支持链式调用，可以解决 Callback Hell (回调地狱) <ul><li>回调地狱: 外部回调函数异步执行结果是内部嵌套的回调执行的条件</li><li>回调地狱不便于阅读和异常处理</li></ul></li><li>语法上 Promise 是一个构造函数</li><li>功能上 promise 对象用来封装一个异步操作并可以获取其成功或失败的结果值</li></ul><h3 id="文档" tabindex="-1">文档 <a class="header-anchor" href="#文档" aria-label="Permalink to &quot;文档&quot;">​</a></h3><ul><li><a href="https://www.ituring.com.cn/article/66566" target="_blank" rel="noreferrer">Promises/A+规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/25178630" target="_blank" rel="noreferrer">Promise 实现详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/30797777" target="_blank" rel="noreferrer">Promise 必知必会（十道题）</a></li></ul><h3 id="promise-三种状态" tabindex="-1">Promise 三种状态 <a class="header-anchor" href="#promise-三种状态" aria-label="Permalink to &quot;Promise 三种状态&quot;">​</a></h3><ul><li><code>Pending</code> 等待态 <ul><li>可以转变为 <code>Fulfilled</code> 或 <code>Rejected</code></li></ul></li><li><code>Fulfilled</code> 执行态 <ul><li>不能转变为其他状态</li><li>必须有一个不可变的 <code>eventual value</code> (终值)</li></ul></li><li><code>Rejected</code> 拒绝态 <ul><li>不能转变为其他状态</li><li>必须有一个不可变的 <code>reason</code> (拒因)</li></ul></li></ul><h2 id="promise-api" tabindex="-1">Promise Api <a class="header-anchor" href="#promise-api" aria-label="Permalink to &quot;Promise Api&quot;">​</a></h2><h3 id="promise-prototype-constructor" tabindex="-1">Promise.prototype.constructor() <a class="header-anchor" href="#promise-prototype-constructor" aria-label="Permalink to &quot;Promise.prototype.constructor()&quot;">​</a></h3><p>Promise 接收一个函数做参数，该函数里有 resolve 和 reject 两个 Promise 内置方法作为参数，异步操作执行结束调用该函数，确定 Promise 最终的状态 (<code>fulfilled</code> 或者 <code>rejected</code>)</p><h3 id="promise-prototype-then" tabindex="-1">Promise.prototype.then() <a class="header-anchor" href="#promise-prototype-then" aria-label="Permalink to &quot;Promise.prototype.then()&quot;">​</a></h3><p>Promise 实例确定后，使用 <code>then</code> 方法指定不同状态的回调函数。then 方法有两个参数，第一个参数 <code>onfulfilled</code> 对应 <code>fulfilled</code> 状态的回调，第二个参数 <code>onrejected</code> 对应<code>rejected</code> 状态的回调</p><h3 id="promise-prototype-catch" tabindex="-1">Promise.prototype.catch() <a class="header-anchor" href="#promise-prototype-catch" aria-label="Permalink to &quot;Promise.prototype.catch()&quot;">​</a></h3><p>Promise 对象的 <code>catch</code> 方法是 <code>then(null, onrejected)</code> 方法的别名，用于指定 <code>rejected</code> 状态的回调，同时还可以捕获 <code>onfulfillled</code> 回调抛出的异常，<code>onrejected</code> 回调无法做到。</p><p>Promise 的错误如果没有捕获会一直往外抛，与 &quot;冒泡&quot; 类似</p><h3 id="promise-prototype-finally" tabindex="-1">Promise.prototype.finally() <a class="header-anchor" href="#promise-prototype-finally" aria-label="Permalink to &quot;Promise.prototype.finally()&quot;">​</a></h3><p>Promise 对象的 <code>finally</code> 方法指定 Promise 对象最终执行的操作，该方法会忽略 Promise 对象的状态，无论 Promise 对象状态如何都会执行该方法的回调</p><h3 id="promise-all" tabindex="-1">Promise.all() <a class="header-anchor" href="#promise-all" aria-label="Permalink to &quot;Promise.all()&quot;">​</a></h3><p><code>Promise.all()</code> 方法的参数是一个数组，该数组所有元素必须为 Promise 实例。<code>Promise.all()</code> 方法可以并行执行异步操作，在所有异步操作执行完后才执行回调。只要有数组中一个 Promise 实例返回 <code>rejected</code> 状态，<code>Promise.all()</code> 最终返回的 Promise 实例即为 <code>rejected</code> 状态，且第一个 <code>rejected</code> 实例的返回值会传给 <code>Promise.all()</code> 的回调函数</p><h3 id="promise-race" tabindex="-1">Promise.race() <a class="header-anchor" href="#promise-race" aria-label="Permalink to &quot;Promise.race()&quot;">​</a></h3><p><code>Promise.race()</code> 方法与 <code>Promise.all()</code> 方法类似，同样接收一个元素为 Promise 实例的数组作为参数，不同的是 <code>Promise.race()</code> 方法不论结果如何，只返回异步操作执行最快的 Promise 实例的状态</p><h3 id="promise-resolve" tabindex="-1">Promise.resolve() <a class="header-anchor" href="#promise-resolve" aria-label="Permalink to &quot;Promise.resolve()&quot;">​</a></h3><p><code>Promise.resolve()</code> 方法可以将现有对象转化为 Promise 对象，转化后的状态为 <code>fulfilled</code> ，如果传入 Promise 对象，则直接返回该 Promise 对象的状态</p><h3 id="promise-reject" tabindex="-1">Promise.reject() <a class="header-anchor" href="#promise-reject" aria-label="Permalink to &quot;Promise.reject()&quot;">​</a></h3><p><code>Promise.reject(reason)</code> 方法返回一个新的 Promise 对象，该对象的状态为 <code>rejected</code></p>',24),t=[l];function c(s,d,m,p,n,h){return r(),o("div",null,t)}const f=e(a,[["render",c]]);export{u as __pageData,f as default};
